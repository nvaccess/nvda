# -*- coding: UTF-8 -*-
#brailleInput.py
#A part of NonVisual Desktop Access (NVDA)
#This file is covered by the GNU General Public License.
#See the file COPYING for more details.
#Copyright (C) 2012-2016 NV Access Limited, Rui Batista

import os.path
import louis
import brailleTables
import braille
import config
from logHandler import log
import winUser
import inputCore
import speech
import keyboardHandler
import api

"""Framework for handling braille input from the user.
All braille input is represented by a {BrailleInputGesture}.
Normally, all that is required is to create and execute a L{BrailleInputGesture},
as there are built-in gesture bindings for braille input.
"""

DOT7 = 1 << 6
DOT8 = 1 << 7
#: This bit flag must be added to all braille cells when using liblouis with dotsIO.
LOUIS_DOTS_IO_START = 0x8000
#: The start of the Unicode braille range.
#: @type: int
UNICODE_BRAILLE_START = 0x2800
#: The Unicode braille character to use when masking cells in protected fields.
#: @type: unicode
UNICODE_BRAILLE_PROTECTED = u"â£¿" # All dots down
#: The letters "zz" in braille (dot 1 3 5 6 twice).
#: This is used by L{brailleInputHandler._translateForReportContractedCell}.
BRAILLE_ZZ = [0b110101] * 2 

#: The singleton BrailleInputHandler instance.
#: @type: L{BrailleInputHandler}
handler = None

def initialize():
	global handler
	handler = BrailleInputHandler()
	log.info("Braille input initialized")

def terminate():
	global handler
	handler = None

class BrailleInputHandler(object):
	"""Handles braille input.
	"""

	def __init__(self):
		self._table = brailleTables.getTable(config.conf["braille"]["inputTable"])
		#: A buffer of entered braille cells so that state set by previous cells can be maintained;
		#: e.g. capital and number signs.
		self.bufferBraille = []
		#: The text translated so far from the cells in L{bufferBraille}.
		self.bufferText = u""
		#: Indexes of cells which produced text.
		#: For example, this includes letters and numbers, but not number signs,
		#: since a number sign by itself doesn't produce text.
		#: This is used when erasing cells to determine when to backspace an actual character.
		self.cellsWithText = set()
		#: The cells in L{bufferBraille} that have not yet been translated
		#: or were translated but did not produce any text.
		#: This is used to show these cells to the user while they're entering braille.
		#: This is a string of Unicode braille.
		#: @type: unicode
		self.untranslatedBraille = ""
		#: The position in L{brailleBuffer} where untranslated braille begins.
		self.untranslatedStart = 0
		#: The user's cursor position within the untranslated braille.
		#: This enables the user to move within the untranslated braille.
		self.untranslatedCursorPos = 0

	@property
	def table(self):
		"""The translation table to use for braille input.
		@rtype: L{brailleTables.BrailleTable}
		"""
		return self._table

	@table.setter
	def table(self, table):
		self._table = table
		config.conf["braille"]["inputTable"] = table.fileName

	def _translate(self, endWord):
		"""Translate buffered braille up to the cursor.
		Any text produced is sent to the system.
		@param endWord: C{True} if this is the end of a word, C{False} otherwise.
		@type endWord: bool
		@return: C{True} if translation produced text, C{False} if not.
		@rtype: bool
		"""
		assert not self._table.contracted or endWord, "Must only translate contracted at end of word"
		if self._table.contracted:
			# self.bufferText has been used by _reportContractedCell, so clear it.
			self.bufferText = u""
		oldTextLen = len(self.bufferText)
		pos = self.untranslatedStart + self.untranslatedCursorPos
		data = u"".join([unichr(cell | LOUIS_DOTS_IO_START) for cell in self.bufferBraille[:pos]])
		self.bufferText = louis.backTranslate(
			[os.path.join(brailleTables.TABLES_DIR, self._table.fileName),
			"braille-patterns.cti"],
			data, mode=louis.dotsIO)[0]
		newText = self.bufferText[oldTextLen:]
		if newText:
			# New text was generated by the cells just entered.
			if self._table.contracted:
				# For contracted braille, an entire word is sent at once.
				# Don't speak characters as this is sent.
				speech._suppressSpeakTypedCharacters(len(newText))
			self.untranslatedStart = pos
			self.untranslatedCursorPos = 0
			self.sendChars(newText)

		if endWord:
			# We only need to buffer one word.
			# Clear the previous word (anything before the cursor) from the buffer.
			del self.bufferBraille[:pos]
			self.bufferText = u""
			self.cellsWithText.clear()
			self.untranslatedStart = 0
			self.untranslatedCursorPos = 0

		if newText or endWord:
			self._updateUntranslated()
			return True

		return False

	def _translateForReportContractedCell(self, pos):
		"""Translate text for current input as required by L{_reportContractedCell}.
		@return: The previous translated text.
		@rtype: unicode
		"""
		# Append braille "zz" so full word contractions don't take effect.
		cells = self.bufferBraille[:pos + 1] + BRAILLE_ZZ
		data = u"".join([unichr(cell | LOUIS_DOTS_IO_START) for cell in cells])
		oldText = self.bufferText
		text = louis.backTranslate(
			[os.path.join(brailleTables.TABLES_DIR, self._table.fileName),
			"braille-patterns.cti"],
			data, mode=louis.dotsIO)[0]
		# Strip the "zz".
		self.bufferText = text[:-2]
		return oldText

	def _reportContractedCell(self, pos):
		"""Report a guess about the character(s) produced by a cell of contracted braille.
		It's not possible to report the exact characters because later cells might change text produced by earlier cells.
		However, it's helpful for the user to have a rough idea.
		For example, in English contracted braille, "alw" is the contraction for "always".
		As the user types "alw", the characters a, l, w will be spoken.
		@return: C{True} if a guess was reported, C{False} if not (e.g. a number sign).
		@rtype: bool
		"""
		oldText = self._translateForReportContractedCell(pos)
		oldTextLen = len(oldText)
		if oldText != self.bufferText[:oldTextLen]:
			# This cell caused the text before it to change, so we can't make a useful guess.
			return False
		newText = self.bufferText[oldTextLen:]
		if newText:
			# New text was generated by the cells just entered.
			# Speak them as separate characters.
			speech.speakMessage(" ".join(newText))
			return True
		return False

	def _reportUntranslated(self, pos):
		"""Report a braille cell which hasn't yet been translated into text.
		"""
		speakTyped = config.conf["keyboard"]["speakTypedCharacters"]
		protected = api.isTypingProtected()
		if speakTyped:
			if protected:
				speech.speakSpelling(speech.PROTECTED_CHAR)
			elif not self._table.contracted or not self._reportContractedCell(pos):
				dots = self.bufferBraille[pos]
				speakDots(dots)
		if self._table.contracted and (not speakTyped or protected):
			# Even if we're not speaking contracted cells, we might need to start doing so midword.
			# For example, the user might have speak typed characters disabled, but enable it midword.
			# Update state needed to report contracted cells.
			self._translateForReportContractedCell(pos)
		self._updateUntranslated()
		self.updateDisplay()

	def input(self, dots):
		"""Handle one cell of braille input.
		"""
		# Insert the newly entered cell into the buffer at the cursor position.
		pos = self.untranslatedStart + self.untranslatedCursorPos
		self.bufferBraille.insert(pos, dots)
		self.untranslatedCursorPos += 1
		# Space ends the word.
		endWord = dots == 0
		# For uncontracted braille, translate the buffer for each cell added.
		# Any new characters produced are then sent immediately.
		# For contracted braille, translate the buffer only when a word is ended (i.e. a space is typed).
		# This is because later cells can change characters produced by previous cells.
		# For example, in English grade 2, "tg" produces just "tg",
		# but "tgr" produces "together".
		if not self._table.contracted or endWord:
			if self._translate(endWord):
				if not endWord:
					self.cellsWithText.add(pos)
			else:
				# This cell didn't produce any text; e.g. number sign.
				self._reportUntranslated(pos)
		else:
			self._reportUntranslated(pos)

	def enter(self):
		"""Translates any braille input and presses the enter key.
		"""
		self._translate(True)
		inputCore.manager.emulateGesture(keyboardHandler.KeyboardInputGesture.fromName("enter"))

	def translate(self):
		"""Translates any braille input without inserting a space or new line.
		"""
		self._translate(True)

	def _updateUntranslated(self):
		"""Update the untranslated braille to be shown to the user.
		If the display will not otherwise be updated, L{updatedisplay} should be called after this.
		"""
		if api.isTypingProtected():
			self.untranslatedBraille = UNICODE_BRAILLE_PROTECTED * (len(self.bufferBraille) - self.untranslatedStart)
		else:
			self.untranslatedBraille = "".join([unichr(UNICODE_BRAILLE_START + dots) for dots in self.bufferBraille[self.untranslatedStart:]])

	def updateDisplay(self):
		"""Update the braille display to reflect untranslated input.
		"""
		region = braille.handler.mainBuffer.regions[-1] if braille.handler.mainBuffer.regions else None
		if isinstance(region, braille.TextInfoRegion):
			braille.handler._doCursorMove(region)

	def eraseLastCell(self):
		# Get the index of the cell being erased.
		index = self.untranslatedStart + self.untranslatedCursorPos - 1
		if index < 0:
			# Erasing before the start of the buffer.
			inputCore.manager.emulateGesture(keyboardHandler.KeyboardInputGesture.fromName("backspace"))
			return
		cell = self.bufferBraille.pop(index)
		if index in self.cellsWithText:
			# Erase a real character.
			inputCore.manager.emulateGesture(keyboardHandler.KeyboardInputGesture.fromName("backspace"))
			char = self.bufferText[-1]
			self.bufferText = self.bufferText[:-1]
			region = braille.handler.mainBuffer.regions[-1] if braille.handler.mainBuffer.regions else None
			if (not isinstance(region, braille.TextInfoRegion) or region.cursorPos is None
				or region.rawText[region.cursorPos - 1] != char
			):
				# The character before the cursor isn't the character we expected to erase.
				# The cursor must have moved between typing and erasing.
				# Thus, the buffer is now invalid.
				self.flushBuffer()
				return
			self.cellsWithText.remove(index)
			self.untranslatedStart -= 1
			self.untranslatedCursorPos = 0
			# This might leave us with some untranslated braille.
			# For example, in English grade 1, erasing the number 1 leaves us with a number sign.
			for prevIndex in xrange(index - 1, -1, -1):
				if  prevIndex in self.cellsWithText:
					# This cell produced text, so stop.
					break
				# This cell didn't produce text (e.g. number sign),
				# so show this untranslated input to the user.
				self.untranslatedStart = prevIndex
				self.untranslatedCursorPos += 1
			if self.untranslatedCursorPos > 0:
				self._updateUntranslated()
				self.updateDisplay()
		else:
			# This cell didn't produce text.
			if self._table.contracted:
				# Update state needed to report contracted cells.
				self._translateForReportContractedCell(index)
			speakDots(cell)
			self.untranslatedCursorPos -= 1
			self._updateUntranslated()
			self.updateDisplay()

	def flushBuffer(self):
		self.bufferBraille = []
		self.bufferText = u""
		self.cellsWithText.clear()
		self.untranslatedBraille = ""
		self.untranslatedStart = 0
		self.untranslatedCursorPos = 0

	def sendChars(self, chars):
		inputs = []
		for ch in chars:
			for direction in (0,winUser.KEYEVENTF_KEYUP): 
				input = winUser.Input()
				input.type = winUser.INPUT_KEYBOARD
				input.ii.ki = winUser.KeyBdInput()
				input.ii.ki.wScan = ord(ch)
				input.ii.ki.dwFlags = winUser.KEYEVENTF_UNICODE|direction
				inputs.append(input)
		winUser.SendInput(inputs)

	def handleGainFocus(self, obj):
		# Clear all state when the focus changes.
		self.flushBuffer()

	def handleConfigProfileSwitch(self):
		table = config.conf["braille"]["inputTable"]
		if table != self._table.fileName:
			self._table = brailleTables.getTable(table)

def formatDotNumbers(dots):
	out = []
	for dot in xrange(8):
		if dots & (1 << dot):
			out.append(str(dot + 1))
	return " ".join(out)

def speakDots(dots):
	# Translators: Used when reporting braille dots to the user.
	speech.speakMessage(_("dot") + " " + formatDotNumbers(dots))

class BrailleInputGesture(inputCore.InputGesture):
	"""Input (dots and/or space bar) from a braille keyboard.
	This could either be as part of a braille display or a stand-alone unit.
	L{dots} and L{space} should be set appropriately.
	"""

	#: Bitmask of pressed dots.
	#: @type: int
	dots = 0

	#: Whether the space bar is pressed.
	#: @type: bool
	space = False

	def _makeDotsId(self):
		# Items separated by a plus sign need to be in Python set order.
		items = {"dot%d" % (i+1) for i in xrange(8) if self.dots & (1 << i)}
		if self.space:
			items.add("space")
		return "bk:" + "+".join(items)

	def _get_identifiers(self):
		if self.space and self.dots:
			# Items separated by a plus sign need to be in Python set order.
			generic = "bk:" + "+".join({"space", "dots"})
			return (self._makeDotsId(), generic)
		elif self.dots in (DOT7, DOT8, DOT7 | DOT8):
			# Allow bindings to dots 7 and/or 8 by themselves.
			return (self._makeDotsId(), "bk:dots")
		elif self.dots or self.space:
			return ("bk:dots",)
		else:
			return ()

	def _get_displayName(self):
		if not self.dots and not self.space:
			return None
		# Translators: Reported before braille input in input help mode.
		out = _("braille") + " "
		if self.space and self.dots:
			# Translators: Reported when braille space is pressed with dots in input help mode.
			out += _("space with dot")
		elif self.dots:
			# Translators: Reported when braille dots are pressed in input help mode.
			out += _("dot")
		elif self.space:
			# Translators: Reported when braille space is pressed in input help mode.
			out += _("space")
		if self.dots:
			out += " " + formatDotNumbers(self.dots)
		return out
