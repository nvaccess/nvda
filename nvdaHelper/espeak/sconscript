from include.scons.SCons.Util import CLVar

Import([
	'thirdPartyEnv',
	'sourceDir',
])

import os
import ctypes
from glob import glob

class AutoFreeCDLL(ctypes.CDLL):
	def __del__(self):
		ctypes.windll.kernel32.FreeLibrary(self._handle)

synthDriversDir=sourceDir.Dir('synthDrivers')
espeakRepo=Dir("#include/espeak")
espeakSrcDir=espeakRepo.Dir('src')
espeakIncludeDir=espeakSrcDir.Dir('include')
sonicSrcDir=Dir("#include/sonic")

class espeak_VOICE(ctypes.Structure):
	_fields_=[
		('name',ctypes.c_char_p),
		('languages',ctypes.c_char_p),
		('identifier',ctypes.c_char_p),
		('gender',ctypes.c_byte),
		('age',ctypes.c_byte),
		('variant',ctypes.c_byte),
		('xx1',ctypes.c_byte),
		('score',ctypes.c_int),
		('spare',ctypes.c_void_p),
	]

env = thirdPartyEnv.Clone()
env.Append(
	CCFLAGS=[
		# Whole-program optimization causes eSpeak to distort and warble with its Klatt4 voice
		# Therefore specifically force it off
		'/GL-',
		# Ignore all warnings as the code is not ours.
		'/W0',
		# Preprocessor definitions. Migrated from 'nvdaHelper/espeak/config.h'
		'/DPACKAGE_VERSION=\\"1.51-dev\\"',  # See 'include/espeak/src/windows/config.h'
		'/DHAVE_STDINT_H=1',
		'/D__WIN32__#1',
		'/DLIBESPEAK_NG_EXPORT',
		# Define WIN32_LEAN_AND_MEAN for preprocessor to prevent windows.h including winsock causing redefinition
		# errors when winsock2 is included by espeak\src\include\compat\endian.h
		'/DWIN32_LEAN_AND_MEAN',
		# Preprocessor definitions. Espeak Features
		'/DINCLUDE_SPEECHPLAYER=1',
		'/DINCLUDE_KLATT=1',
		'/DHAVE_SONIC_H=1',
	])

env.Append(
	CPPPATH=[
		'#nvdaHelper/espeak',  # ensure that nvdaHelper/espeak/config.h is found first.
		espeakIncludeDir,
		espeakIncludeDir.Dir('compat'),
		espeakSrcDir.Dir('speechPlayer/include'),
		sonicSrcDir,
		espeakSrcDir.Dir('ucd-tools/src/include')
	])

def espeak_compilePhonemeData_buildEmitter(target,source,env):
	phSourceIgnores=['error_log','error_intonation','compile_prog_log','compile_report','envelopes.png']
	phSources=env.Flatten([[Dir(topDir).File(f) for f in files if f not in phSourceIgnores] for topDir,subdirs,files in os.walk(source[0].abspath)])
	sources=env.Flatten([phSources])
	targets=[target[0].File(f) for f in ['intonations','phondata','phondata-manifest','phonindex','phontab']]
	phSideEffects=[source[0].File(x) for x in phSourceIgnores]
	env.SideEffect(phSideEffects,targets)
	return targets,sources

def espeak_compilePhonemeData_buildAction(target,source,env):
	# We want the eSpeak dll to be freed after each dictionary.
	# This is because it writes to stderr but doesn't flush it.
	# Unfortunately, there's no way we can flush it or use a different stream
	# because our eSpeak statically links the CRT.
	espeak=AutoFreeCDLL(espeakLib[0].abspath)
	espeak.espeak_ng_InitializePath(os.fsencode(espeakRepo.abspath))
	espeak.espeak_ng_CompileIntonation(None,None)
	espeak.espeak_ng_CompilePhonemeData(22050,None,None)
	espeak.espeak_Terminate()

env['BUILDERS']['espeak_compilePhonemeData']=Builder(action=env.Action(espeak_compilePhonemeData_buildAction,"Compiling phoneme data"),emitter=espeak_compilePhonemeData_buildEmitter)

def espeak_compileDict_buildAction(target,source,env):
	# We want the eSpeak dll to be freed after each dictionary.
	# This is because it writes to stderr but doesn't flush it.
	# Unfortunately, there's no way we can flush it or use a different stream
	# because our eSpeak statically links the CRT.
	espeak=AutoFreeCDLL(espeakLib[0].abspath)
	espeak.espeak_Initialize(0,0,os.fsencode(target[0].Dir('..').abspath),0x8000)
	try:
		lang=source[0].name.split('_')[0].encode()
		v=espeak_VOICE(languages=lang+b'\x00')
		if espeak.espeak_SetVoiceByProperties(ctypes.byref(v))!=0:
			print("espeak_compileDict_action: failed to switch to language %s"%lang)
			return 1
		dictPath=os.fsencode(os.path.split(source[0].abspath)[0]+'/')
		if espeak.espeak_ng_CompileDictionary(dictPath,None,0,None)!=0:
			print("espeak_compileDict_action: failed to compile dictionary for  language %s"%lang)
			return
	finally:
		espeak.espeak_Terminate()

sonicLib=env.StaticLibrary(
	target='sonic',
	srcdir=sonicSrcDir.abspath,
	source='sonic.c',
)

espeakLib=env.SharedLibrary(
	target='espeak',
	srcdir=espeakSrcDir.Dir('libespeak-ng').abspath,
	source=[
		# compare to src_libespeak_ng_la_SOURCES in espeak Makefile.am
		"../ucd-tools/src/case.c",
		"../ucd-tools/src/categories.c",
		"../ucd-tools/src/ctype.c",
		"../ucd-tools/src/proplist.c",
		"../ucd-tools/src/scripts.c",
		"../ucd-tools/src/tostring.c",
		"compiledata.c",
		"compiledict.c",
#		"compilembrola.c", # we dont use MBROLA, this is a compile option in espeak
		"dictionary.c",
		"encoding.c",
		"error.c",
		"espeak_api.c",
		"ieee80.c",
		"intonation.c",
		"klatt.c", # we do use KLATT, this is a compile option in espeak
#		"mbrowrap.c", # we don't use MBROLA, this is a compile option in espeak
		"mnemonics.c",
		"numbers.c",
		"phoneme.c",
		"phonemelist.c",
		"readclause.c",
		"setlengths.c",
		"spect.c",
		"speech.c",
		"ssml.c",
		"synthdata.c",
		"synthesize.c",
		"synth_mbrola.c", # provides symbols used by synthesize.obj, voices.obj, and wavegen.obj
		"translate.c",
		"tr_languages.c",
		"voices.c",
		"wavegen.c",
		sonicLib,
		# espeak OPT_SPEECHPLAYER block
		"sPlayer.c",
		"../speechPlayer/src/frame.cpp",
		"../speechPlayer/src/speechPlayer.cpp",
		"../speechPlayer/src/speechWaveGenerator.cpp",
		#"../speak-ng.cpp",
		# if not OPT_SPEECHPLAYER
		# "../speak-ng.c",
		# espeak does not need to handle its own audio output so dont include:
		# pcaudiolib\src\audio.c
		# pcaudiolib\src\windows.c
		# pcaudiolib\src\xaudio2.cpp
		# These are for SAPI5, we dont need them:
		# com\comentrypoints.c
		# com\ttsengine.cpp
		# We do not use the ASYNC compile option in espeak.
	],
	LIBS=['advapi32'],
)

phonemeData=env.espeak_compilePhonemeData(espeakRepo.Dir('espeak-ng-data'),espeakRepo.Dir('phsource'))
env.Depends(phonemeData,espeakLib)
for i in phonemeData:
	iDir = espeakRepo.Dir('espeak-ng-data').abspath
	l = len(iDir) + 1
	fileName = i.abspath[l:]
	env.InstallAs(os.path.join(synthDriversDir.Dir('espeak-ng-data').abspath, fileName), i)

# Move any extra dictionaries into dictsource for compilation
env.Install(espeakRepo.Dir('dictsource'),env.Glob(os.path.join(espeakRepo.abspath,'dictsource','extra','*_*')))

#Compile all dictionaries
missingDicts=['zhy', ] #'mt','tn','tt']
dictSourcePath=espeakRepo.Dir('dictsource').abspath
# Remove emoji files before compiling dictionaries.
# Currently many of these simply crash eSpeak at runtime.
# Also, our own emoji processing using CLDR data is preferred.
emojiGlob = os.path.join(espeakRepo.abspath,'dictsource','*_emoji')
for f in glob(emojiGlob):
	print("Removing emoji file: %s"%f)
	os.remove(f)
for f in env.Glob(os.path.join(dictSourcePath,'*_rules')):
	lang=f.name.split('_')[0]
	if lang in missingDicts: continue
	dictFileName = lang+'_dict'
	dictFile=env.Command(espeakRepo.Dir('espeak-ng-data').File(dictFileName),f,espeak_compileDict_buildAction)
	dictDeps=env.Glob(os.path.join(espeakRepo.abspath,'dictsource',lang+'_*'))
	dictDeps.remove(f)
	env.Depends(dictFile,dictDeps)
	env.Depends(dictFile,[espeakLib,phonemeData])
	#Dictionaries can not be compiled in parallel, force SCons not to do this
	env.SideEffect('_espeak_compileDict',dictFile)
	env.InstallAs(os.path.join(synthDriversDir.Dir('espeak-ng-data').abspath, dictFileName), dictFile)

env.Install(synthDriversDir,espeakLib)

# install espeak-ng-data
targetEspeakDataDir=synthDriversDir.Dir('espeak-ng-data')
espeakDataSource=espeakRepo.Dir('espeak-ng-data')

# also install the lang and voices/!v directories. Exclude the voices/mb directory since we are not using mbrola.
env.RecursiveInstall(targetEspeakDataDir.Dir('lang'),espeakDataSource.Dir('lang').abspath)
env.RecursiveInstall(targetEspeakDataDir.Dir('voices').Dir('!v'),espeakDataSource.Dir('voices').Dir('!v').abspath)
