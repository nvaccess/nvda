import enum
import typing
import os
import ctypes
import SCons.Node
import SCons.Node.FS
import SCons.Environment
from glob import glob

sourceDir: SCons.Node.FS.Dir
thirdPartyEnv: SCons.Environment.Environment

Import([
	'thirdPartyEnv',
	'sourceDir',
])

class AutoFreeCDLL(ctypes.CDLL):
	def __del__(self):
		ctypes.windll.kernel32.FreeLibrary(self._handle)

synthDriversDir=sourceDir.Dir('synthDrivers')
espeakRepo=Dir("#include/espeak")
espeakSrcDir=espeakRepo.Dir('src')
espeakIncludeDir=espeakSrcDir.Dir('include')
sonicSrcDir=Dir("#include/sonic")

class espeak_ERROR(enum.IntEnum):
	EE_OK = 0
	EE_INTERNAL_ERROR = -1
	EE_BUFFER_FULL = 1
	EE_NOT_FOUND = 2

class espeak_ng_STATUS(enum.IntEnum):
	ENS_GROUP_MASK = 0x70000000
	ENS_GROUP_ERRNO = 0x00000000  # Values 0 - 255 map to errno error codes.
	ENS_GROUP_ESPEAK_NG = 0x10000000  # eSpeak NG error codes.

	# eSpeak NG 1.49.0
	ENS_OK = 0
	ENS_COMPILE_ERROR = 0x100001FF
	ENS_VERSION_MISMATCH = 0x100002FF
	ENS_FIFO_BUFFER_FULL = 0x100003FF
	ENS_NOT_INITIALIZED = 0x100004FF
	ENS_AUDIO_ERROR = 0x100005FF
	ENS_VOICE_NOT_FOUND = 0x100006FF
	ENS_MBROLA_NOT_FOUND = 0x100007FF
	ENS_MBROLA_VOICE_NOT_FOUND = 0x100008FF
	ENS_EVENT_BUFFER_FULL = 0x100009FF
	ENS_NOT_SUPPORTED = 0x10000AFF
	ENS_UNSUPPORTED_PHON_FORMAT = 0x10000BFF
	ENS_NO_SPECT_FRAMES = 0x10000CFF
	ENS_EMPTY_PHONEME_MANIFEST = 0x10000DFF
	ENS_SPEECH_STOPPED = 0x10000EFF

	# eSpeak NG 1.49.2
	ENS_UNKNOWN_PHONEME_FEATURE = 0x10000FFF
	ENS_UNKNOWN_TEXT_ENCODING = 0x100010FF

class espeak_VOICE(ctypes.Structure):
	_fields_=[
		('name',ctypes.c_char_p),
		('languages',ctypes.c_char_p),
		('identifier',ctypes.c_char_p),
		('gender',ctypes.c_byte),
		('age',ctypes.c_byte),
		('variant',ctypes.c_byte),
		('xx1',ctypes.c_byte),
		('score',ctypes.c_int),
		('spare',ctypes.c_void_p),
	]


class espeak_AUDIO_OUTPUT(enum.IntEnum):
	"""From '/espeak-ng/speak_lib.h'
	"""
	#: PLAYBACK mode: plays the audio data, supplies events to the calling program
	AUDIO_OUTPUT_PLAYBACK = 0
	#: RETRIEVAL mode: supplies audio data and events to the calling program
	AUDIO_OUTPUT_RETRIEVAL = 1
	#: SYNCHRONOUS mode: as RETRIEVAL but doesn't return until synthesis is completed
	AUDIO_OUTPUT_SYNCHRONOUS = 2
	#: Synchronous playback
	AUDIO_OUTPUT_SYNCH_PLAYBACK = 3

env: SCons.Environment.Environment = thirdPartyEnv.Clone()
env.Append(
	CCFLAGS=[
		# Whole-program optimization causes eSpeak to distort and warble with its Klatt4 voice
		# Therefore specifically force it off
		'/GL-',
		# Ignore all warnings as the code is not ours.
		'/W0',
		# Preprocessor definitions. Migrated from 'nvdaHelper/espeak/config.h'
		'/DPACKAGE_VERSION=\\"1.51-dev\\"',  # See 'include/espeak/src/windows/config.h'
		'/DHAVE_STDINT_H=1',
		'/D__WIN32__#1',
		'/DLIBESPEAK_NG_EXPORT',
		# Define WIN32_LEAN_AND_MEAN for preprocessor to prevent windows.h including winsock causing redefinition
		# errors when winsock2 is included by espeak\src\include\compat\endian.h
		'/DWIN32_LEAN_AND_MEAN',
		# Preprocessor definitions. Espeak Features
		'/DINCLUDE_SPEECHPLAYER=1',
		'/DINCLUDE_KLATT=1',
		'/DHAVE_SONIC_H=1',
	])

env.Append(
	CPPPATH=[
		'#nvdaHelper/espeak',  # ensure that nvdaHelper/espeak/config.h is found first.
		espeakIncludeDir,
		espeakIncludeDir.Dir('compat'),
		espeakSrcDir.Dir('speechPlayer/include'),
		sonicSrcDir,
		espeakSrcDir.Dir('ucd-tools/src/include')
	])

def espeak_compilePhonemeData_buildEmitter(target,source,env):
	phSourceIgnores=['error_log','error_intonation','compile_prog_log','compile_report','envelopes.png']
	phSources=env.Flatten([[Dir(topDir).File(f) for f in files if f not in phSourceIgnores] for topDir,subdirs,files in os.walk(source[0].abspath)])
	sources=env.Flatten([phSources])
	targets=[target[0].File(f) for f in ['intonations','phondata','phondata-manifest','phonindex','phontab']]
	phSideEffects=[source[0].File(x) for x in phSourceIgnores]
	env.SideEffect(phSideEffects,targets)
	return targets,sources

def espeak_compilePhonemeData_buildAction(target,source,env):
	# We want the eSpeak dll to be freed after each dictionary.
	# This is because it writes to stderr but doesn't flush it.
	# Unfortunately, there's no way we can flush it or use a different stream
	# because our eSpeak statically links the CRT.
	espeak=AutoFreeCDLL(espeakLib[0].abspath)
	espeak.espeak_ng_InitializePath(os.fsencode(espeakRepo.abspath))
	espeak.espeak_ng_CompileIntonation(None,None)
	espeak.espeak_ng_CompilePhonemeData(22050,None,None)
	espeak.espeak_Terminate()

env['BUILDERS']['espeak_compilePhonemeData']=Builder(action=env.Action(espeak_compilePhonemeData_buildAction,"Compiling phoneme data"),emitter=espeak_compilePhonemeData_buildEmitter)

#: See dictionaries section of /include/espeak/Makefile.am
espeakDictionaryCompileList: typing.Dict[
	str, # expected dict file name EG 'es_dict'
	typing.Tuple[str, str] # rules file and language code. EG, ('es_rules, 'es'))
] = {
	"af_dict": ("af_rules", "af"),
	"am_dict": ("am_rules", "am"),
	"an_dict": ("an_rules", "an"),
	"ar_dict": ("ar_rules", "ar"),
	"as_dict": ("as_rules", "as"),
	"az_dict": ("az_rules", "az"),
	"ba_dict": ("ba_rules", "ba"),
	"bg_dict": ("bg_rules", "bg"),
	"bn_dict": ("bn_rules", "bn"),
	"bpy_dict": ("bpy_rules", "bpy"),
	"bs_dict": ("bs_rules", "bs"),
	"ca_dict": ("ca_rules", "ca"),
	"chr_dict": ("chr_rules", "chr"),
	"cmn_dict": ("cmn_rules", "cmn"),
	"cs_dict": ("cs_rules", "cs"),
	"cv_dict": ("cv_rules", "cv"),
	"cy_dict": ("cy_rules", "cy"),
	"da_dict": ("da_rules", "da"),
	"de_dict": ("de_rules", "de"),
	"el_dict": ("el_rules", "el"),
	"en_dict": ("en_rules", "en"),
	"eo_dict": ("eo_rules", "eo"),
	"es_dict": ("es_rules", "es"),
	"et_dict": ("et_rules", "et"),
	"eu_dict": ("eu_rules", "eu"),
	"fa_dict": ("fa_rules", "fa"),
	"fi_dict": ("fi_rules", "fi"),
	"fr_dict": ("fr_rules", "fr"),
	"ga_dict": ("ga_rules", "ga"),
	"gd_dict": ("gd_rules", "gd"),
	"gn_dict": ("gn_rules", "gn"),
	"grc_dict": ("grc_rules", "grc"),
	"gu_dict": ("gu_rules", "gu"),
	"hak_dict": ("hak_rules", "hak"),
	"haw_dict": ("haw_rules", "haw"),
	"he_dict": ("he_rules", "he"),
	"hi_dict": ("hi_rules", "hi"),
	"hr_dict": ("hr_rules", "hr"),
	"ht_dict": ("ht_rules", "ht"),
	"hu_dict": ("hu_rules", "hu"),
	"hy_dict": ("hy_rules", "hy"),
	"ia_dict": ("ia_rules", "ia"),
	"id_dict": ("id_rules", "id"),
	"io_dict": ("io_rules", "io"),
	"is_dict": ("is_rules", "is"),
	"it_dict": ("it_rules", "it"),
	"ja_dict": ("ja_rules", "ja"),
	"jbo_dict": ("jbo_rules", "jbo"),
	"ka_dict": ("ka_rules", "ka"),
	"kk_dict": ("kk_rules", "kk"),
	"kl_dict": ("kl_rules", "kl"),
	"kn_dict": ("kn_rules", "kn"),
	"kok_dict": ("kok_rules", "kok"),
	"ko_dict": ("ko_rules", "ko"),
	"ku_dict": ("ku_rules", "ku"),
	"ky_dict": ("ky_rules", "ky"),
	"la_dict": ("la_rules", "la"),
	"lfn_dict": ("lfn_rules", "lfn"),
	"lt_dict": ("lt_rules", "lt"),
	"lv_dict": ("lv_rules", "lv"),
	"mi_dict": ("mi_rules", "mi"),
	"mk_dict": ("mk_rules", "mk"),
	"ml_dict": ("ml_rules", "ml"),
	"mr_dict": ("mr_rules", "mr"),
	"ms_dict": ("ms_rules", "ms"),
	"mt_dict": ("mt_rules", "mt"),
	"my_dict": ("my_rules", "my"),
	"nci_dict": ("nci_rules", "nci"),
	"ne_dict": ("ne_rules", "ne"),
	"nl_dict": ("nl_rules", "nl"),
	"nog_dict": ("nog_rules", "nog"),
	"no_dict": ("no_rules", "no"),
	"om_dict": ("om_rules", "om"),
	"or_dict": ("or_rules", "or"),
	"pap_dict": ("pap_rules", "pap"),
	"pa_dict": ("pa_rules", "pa"),
	"piqd_dict": ("piqd_rules", "piqd"),
	"pl_dict": ("pl_rules", "pl"),
	"pt_dict": ("pt_rules", "pt"),
	"py_dict": ("py_rules", "py"),
	"qdb_dict": ("qdb_rules", "qdb"),
	"quc_dict": ("quc_rules", "quc"),
	"qu_dict": ("qu_rules", "qu"),
	"ro_dict": ("ro_rules", "ro"),
	"ru_dict": ("ru_rules", "ru"),
	"sd_dict": ("sd_rules", "sd"),
	"shn_dict": ("shn_rules", "shn"),
	"si_dict": ("si_rules", "si"),
	"sk_dict": ("sk_rules", "sk"),
	"sl_dict": ("sl_rules", "sl"),
	"smj_dict": ("smj_rules", "smj"),
	"sq_dict": ("sq_rules", "sq"),
	"sr_dict": ("sr_rules", "sr"),
	"sv_dict": ("sv_rules", "sv"),
	"sw_dict": ("sw_rules", "sw"),
	"ta_dict": ("ta_rules", "ta"),
	"te_dict": ("te_rules", "te"),
	"th_dict": ("th_rules", "th"),
	"tk_dict": ("tk_rules", "tk"),
	"tn_dict": ("tn_rules", "tn"),
	"tr_dict": ("tr_rules", "tr"),
	"tt_dict": ("tt_rules", "tt"),
	"ug_dict": ("ug_rules", "ug"),
	"uk_dict": ("uk_rules", "uk"),
	"ur_dict": ("ur_rules", "ur"),
	"uz_dict": ("uz_rules", "uz"),
	"vi_dict": ("vi_rules", "vi"),
	"yue_dict": ("yue_rules", "yue"),
}

def espeak_compileDict_buildAction(
		# SCons docs claim target and source should be a Node, not list, but this is what we get.
		target: typing.List[SCons.Node.FS.File],
		source: typing.List[SCons.Node.FS.File],
		env: SCons.Environment.Environment
) -> int:
	"""
	@param target: The langCode_dict file to build
	@param source: The langCode_rules file
	@param env: Scons build environment
	@return From SCons docs: "Return 0 or None to indicate a successful build of
		the target file(s). The function may raise an exception or return a non-zero
		exit status to indicate an unsuccessful build."
	"""
	if len(target) != 1:
		targetStrings = list((str(t) for t in target))
		raise ValueError(f"Unexpected number of targets: {targetStrings}")
	target = target[0]

	if len(source) != 1:
		sourceStrings = list((str(s) for s in source))
		raise ValueError(f"Unexpected number of source files: {sourceStrings}")
	source = source[0]

	ACTION_SUCCESS = 0
	ACTION_FAILURE = 1

	# We want the eSpeak dll to be freed after each dictionary.
	# This is because it writes to stderr but doesn't flush it.
	# Unfortunately, there's no way we can flush it or use a different stream
	# because our eSpeak statically links the CRT.
	espeak=AutoFreeCDLL(espeakLib[0].abspath)

	# from: espeak-ng/speak_lib.h
	espeakINITIALIZE_DONT_EXIT = 0x8000
	# see: libespeak-ng/espeak_api.c for espeak_Initialize
	espeak.espeak_Initialize(
		espeak_AUDIO_OUTPUT.AUDIO_OUTPUT_PLAYBACK,  # espeak_AUDIO_OUTPUT output_type
		0,  # int buf_length
		os.fsencode(target.Dir('..').abspath),  # const char *path
		espeakINITIALIZE_DONT_EXIT  # int options
	)

	try: # ensure that espeak_Terminate is called
		lang = espeakDictionaryCompileList[target.name][1]
		langRulesName:str = source.name  # example: "es_rules"
		dirForRules:SCons.Node.FS.Base = source.dir
		voice = espeak_VOICE(languages=lang.encode() + b'\x00')

		# see: espeak-ng/speak_lib.h for espeak_SetVoiceByProperties
		# returns: espeak_ERROR
		setVoiceResult = espeak.espeak_SetVoiceByProperties(ctypes.byref(voice))
		if espeak_ERROR.EE_OK.value != setVoiceResult:
			print(
				f"Failed to switch to language: '{lang}'"
				f"\n rules: '{langRulesName}'"
				f"\n result: {espeak_ERROR(setVoiceResult)!s}"
			)
			return ACTION_FAILURE

		rulesPathEncoded = os.fsencode(dirForRules.abspath + '/')
		# see: espeak-ng/espeak_ng.h for espeak_ng_CompileDictionary
		# returns: espeak_ng_STATUS
		compileDictResult = espeak.espeak_ng_CompileDictionary(
			rulesPathEncoded,  # const char *dsource
			None,  # const char *dict_name
			None,  # FILE *log
			0,  # int flags
			None,  # espeak_ng_ERROR_CONTEXT *context
		)
		if espeak_ERROR.EE_OK.value != compileDictResult:
			print(
				f"Failed to compile dictionary: '{target}'"
				f"\n rules: '{langRulesName}'"
				f"\n rulesPath: {rulesPathEncoded}"
				f"\n language: '{lang}'"
				f"\n result: {espeak_ng_STATUS(compileDictResult)!s}"
			)
			return ACTION_FAILURE
	finally:
		espeak.espeak_Terminate()
	return ACTION_SUCCESS

sonicLib=env.StaticLibrary(
	target='sonic',
	srcdir=sonicSrcDir.abspath,
	source='sonic.c',
)

espeakLib=env.SharedLibrary(
	target='espeak',
	srcdir=espeakSrcDir.Dir('libespeak-ng').abspath,
	source=[
		# compare to src_libespeak_ng_la_SOURCES in espeak Makefile.am
		"../ucd-tools/src/case.c",
		"../ucd-tools/src/categories.c",
		"../ucd-tools/src/ctype.c",
		"../ucd-tools/src/proplist.c",
		"../ucd-tools/src/scripts.c",
		"../ucd-tools/src/tostring.c",
		"compiledata.c",
		"compiledict.c",
#		"compilembrola.c", # we dont use MBROLA, this is a compile option in espeak
		"dictionary.c",
		"encoding.c",
		"error.c",
		"espeak_api.c",
		"ieee80.c",
		"intonation.c",
		"klatt.c", # we do use KLATT, this is a compile option in espeak
#		"mbrowrap.c", # we don't use MBROLA, this is a compile option in espeak
		"mnemonics.c",
		"numbers.c",
		"phoneme.c",
		"phonemelist.c",
		"readclause.c",
		"setlengths.c",
		"soundIcon.c",
		"spect.c",
		"speech.c",
		"ssml.c",
		"synthdata.c",
		"synthesize.c",
		"synth_mbrola.c", # provides symbols used by synthesize.obj, voices.obj, and wavegen.obj
		"translate.c",
		"tr_languages.c",
		"voices.c",
		"wavegen.c",
		sonicLib,
		# espeak OPT_SPEECHPLAYER block
		"sPlayer.c",
		"../speechPlayer/src/frame.cpp",
		"../speechPlayer/src/speechPlayer.cpp",
		"../speechPlayer/src/speechWaveGenerator.cpp",
		#"../speak-ng.cpp",
		# if not OPT_SPEECHPLAYER
		# "../speak-ng.c",
		# espeak does not need to handle its own audio output so dont include:
		# pcaudiolib\src\audio.c
		# pcaudiolib\src\windows.c
		# pcaudiolib\src\xaudio2.cpp
		# These are for SAPI5, we dont need them:
		# com\comentrypoints.c
		# com\ttsengine.cpp
		# We do not use the ASYNC compile option in espeak.
	],
	LIBS=['advapi32'],
)

phonemeData=env.espeak_compilePhonemeData(espeakRepo.Dir('espeak-ng-data'),espeakRepo.Dir('phsource'))
env.Depends(phonemeData,espeakLib)
for i in phonemeData:
	iDir = espeakRepo.Dir('espeak-ng-data').abspath
	l = len(iDir) + 1
	fileName = i.abspath[l:]
	env.InstallAs(os.path.join(synthDriversDir.Dir('espeak-ng-data').abspath, fileName), i)

# Move any extra dictionaries into dictsource for compilation
env.Install(espeakRepo.Dir('dictsource'),env.Glob(os.path.join(espeakRepo.abspath,'dictsource','extra','*_*')))

#Compile all dictionaries
excludeLangs: typing.List[str] = [] # Use to exclude languages which don't compile.
dictSourcePath: SCons.Node.FS.Dir = espeakRepo.Dir('dictsource')

# Remove emoji files before compiling dictionaries.
# Currently many of these simply crash eSpeak at runtime.
# Also, our own emoji processing using CLDR data is preferred.
emojiGlob = os.path.join(espeakRepo.abspath,'dictsource','*_emoji')
for f in glob(emojiGlob):
	print("Removing emoji file: %s"%f)
	os.remove(f)

# Create compile commands for all languages
for dictFileName, (rulesFileName, langCode) in espeakDictionaryCompileList.items():
	if langCode in excludeLangs: continue

	rulesFilePath = dictSourcePath.File(rulesFileName)
	dictFilePath = espeakRepo.Dir('espeak-ng-data').File(dictFileName)

	dictFile = env.Command(
		target=dictFilePath,
		source=rulesFilePath,
		action=espeak_compileDict_buildAction
	)

	# Find all files related to "langCode", these are all dependencies for the language.
	dictDeps = dictSourcePath.glob(langCode + '_*')
	# Remove, sourceRulesFilePath, SCons already knows the target depends on the source
	try:
		dictDeps.remove(rulesFilePath)
	except Exception:
		print(f"Removing from dictDeps: {rulesFilePath} from \n{dictDeps}")
	env.Depends(dictFile, dictDeps)
	env.Depends(dictFile, [espeakLib, phonemeData])

	# Dictionaries can not be compiled in parallel, force SCons not to do this
	env.SideEffect('_espeak_compileDict',dictFile)
	env.InstallAs( # Install files to the "synthDrivers/espeak-ng-data/" dir.
		os.path.join(synthDriversDir.Dir('espeak-ng-data').abspath, dictFileName),
		dictFile
	)

env.Install(synthDriversDir,espeakLib)

# install espeak-ng-data
targetEspeakDataDir=synthDriversDir.Dir('espeak-ng-data')
espeakDataSource=espeakRepo.Dir('espeak-ng-data')

# also install the lang and voices/!v directories. Exclude the voices/mb directory since we are not using mbrola.
env.RecursiveInstall(targetEspeakDataDir.Dir('lang'),espeakDataSource.Dir('lang').abspath)
env.RecursiveInstall(targetEspeakDataDir.Dir('voices').Dir('!v'),espeakDataSource.Dir('voices').Dir('!v').abspath)
