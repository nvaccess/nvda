NVDA NVDA_VERSION Handbuch für Entwickler


%!includeconf: ../userGuide.t2tconf

% Remove double spacing from the beginning of each line as txt2tags seems to indent preformatted text by two spaces
%!PostProc(html): '^  ' ''

= Inhaltsverzeichnis =[toc]
%%toc

+ Einleitung +
Dieses Handbuch stellt informationen zur Entwicklung von NVDA und dessen Komponenten sowie ihre Übersetzungen bereit.
(HINWEIS: Dies ist lediglich eine Einführung. Für die komplette Referenz ist es für Entwickler empfehlenswert sich die Code-Dokumentation durchzulesen.)

++ Eine Anmerkung zu Python ++
NVDA und dessen Erweiterungen werden in der Programmiersprache Python geschrieben.
Das Ziel dieses Handbuches ist nicht, Ihnen Python beizubringen, lediglich stellt es Beispiele zur Veranschaulichung der Syntax in Python bereit.
Die Dokumentationen und weitere Materialien sind einer oder mehreren der folgenden Bezugsquellen zu finden:
- einen guten Einstieg in Python bietet das Buch [Python http://openbook.galileocomputing.de/python/index.htm#_top] von Galileo computing.
- ein sehr gutes Nachschlagewerk bietet außerdem das [deutsche Python-Wiki http://wiki.python.de/]
- mit Hilfe der Python-Konsole können weitere Informationen über ein bestimmtes Objekt gewonen werden. Wenn Sie den Navigator auf das fragliche Objekt gesetzt und die Python-Konsole aufgerufen haben, können Sie mit den folgenden Befehlen weitere Informationen über dieses Objekt gewinnen:
 - Um die Code-Dokumentation und die Online-Hilfe zu dem aktuellen Navigator-Objekt anzuzeigen, verwenden Sie den folgenden Befehl: help(nav) Die ausgabe des Befehls kann sehr umfangreich sein, weil nicht nur Informationen ber das Navigator-Objekt selbst, sondern auch über alle seine Vorfahren angezeigt werden. Es ist daher zu empfehlen, sich den Inhalt des ausgabefensters in einer Textdatei zu speichern, um bei der weiteren Entwicklungsarbeit darauf zurückgreifen zu können.
 - Um alle Eigenschaften und Methoden des aktuellen Navigator-Objekts als Python-Wörterbuch anzuzeigen, verwenden Sie den folgenden Befehl: dir(nav)


+ Übersetzung +
Damit NVDA mehrere Sprachen/Sprachräume unterstützt, muss es übersetzt und sprachspezifische Daten müssen zur Verfügung gestellt werden.

++ Beschreibungen der Sonderzeichen ++
Manchmal kann es schwierig bis unmöglich sein, zwei Zeichen voneinander zu unterscheiden. 
Zwei Zeichen können beispielsweise identisch ausgesprochen werden, auch wenn es eigentlich völlig unterschiedliche Zeichen sind.
Um dieses problem zu lösen, können Zeichenbeschreibungen bereitgestellt werden, die jedes Zeichen eindeutig beschreiben.

Zeichenbeschreibungen für einen Sprachraum können in einer Datei characterdescriptions.dic bereitgestellt werden, die sich im Verzeichnis des jeweiligen Sprachraums befinden muss.
Die Datei muss utf-8-codiert werden.
Leerzeilen und Zeilen, die mit einem "#" beginnen, werden ignoriert.
alle anderen Zeilen müssen ein Zeichen gefolgt von einem Tabulator und dessen Beschreibung enthalten. 

zum Beispiel:
```
# Dies ist ein Kommentar
a	Anton
b	Berta
```

Ein vollständiges Beispiel finden Sie in der Datei "locale\de\characterDescriptions.dic".

++ Aussprache der Symbole ++
Für Sprachausgabennutzer ist es oft sinnvoll, beim zeichenweisen Navigieren Sonderzeichen als Wörter angesagt zu bekommen.
Unglücklicherweise sprechen verschiedene Sprachausgaben die Sonderzeichen sehr unterschiedlich aus. Manche Sprachausgaben erlauben keine Kontrolle über die Aussprache von Sonderzeichen.
Hierfür können Informationen über die Aussprache von Sonderzeichen in NVDA mitgegeben werden.

Dies kann sprachspezifisch in der UTF8-kodierten Datei namens "Symbols.dic" im Verzeichnis des jeweiligen Sprachraums erfolgen.
Leerzeilen und Zeilen, die mit einem "#" beginnen, werden ignoriert.
Alle Sprachräume erben die Sonderzeichenaussprache des Englischen.

Die Datei enthält zwei Abschnitte.

+++ Komplexe Symbole definieren +++
Der erste Abschnitt ist optional und enthält Definitionen komplexer Symbole in Form regulärer Ausdrücke.
komplexe Symbole sind nicht einfach nur Sonderzeichen oder Sequenzen von Sonderzeichen, die durch Wörter ersetzt werden sollen. stattdessen erfordern sie eine kompliziertere Überprüfung auf Übereinstimmung.
Ein Beispiel ist der Punkt als Satzzeichen im Deutschen.
Da der Punkt mehrere Bedeutungen hat, ist eine komplexere Überprüfung erforderlich um zu bestimmen, ob er sich auch tatsächlich am Ende eines Satzes befindet.

Der Abschnitt für komplexe Symbole beginnt mit der folgenden Zeile:
```
complexSymbols:
```

Die einzelnen Zeilen innerhalb dieses Abschnittes enthalten einen Namen für ein Symbol, ein Tab-Zeichen und einen Regulären Ausdruck für ein Symbol.
zum Beispiel:
```
. Satzende	(?<=[^\s.])\.(?=[\"')\s]|$)
```

Da ein jeder Sprachraum die komplexen Symbole des englischen Sprachraumes erbt, brauchen Sie diese in ihrer Symboldefinition nicht noch einmal aufzuführen.

+++ Symbol-Informationen definieren +++
der zweite Abschnitt enthält Informationen darüber, ob und wie Symbole ausgesprochen werden. 
Er beginnt mit der Zeile:
```
symbols:
```

Die Zeilen dieses Abschnitts enthalten mehrere Felder, die durch Tabstops getrennt sind.
Die einzigen Pflichtfelder sind der Name des Symbols und der Ersatztext.
Für leere Felder wird der Standardwert verwendet.
folgende Felder sind verfügbar:
- Name: Der Name eines Symbols
Meistens wird hier das zu verarbeitende Sonderzeichen oder der name eines komplexen Symbols angegeben. Einige Sonderzeichen können nicht eingegeben werden. Hierfür können die folgenden Sequenzen verwendet werden:
- \0: Null
- \t: Tabulator
- \n: Zeilenumbruch
- \r: Wagenrücklauf
- \f: Seitenvorschub
- \#: #-Zeichen (benötigt einen Backslash, da dieses #-Zeichen sonst als Kommentar angesehen wird)
- Ersatztext: der Text, der anstelle des Symbols ausgesprochen werden soll.
- Ebene: die Symbolebene, ab der das Symbol gesprochen werden soll.
Die Symbolebene kann vom Anwender konfiguriert werden und gibt die Menge an auszusprechenden Sonderzeichen an. 
Dieses Feld sollte einen der Werte  "none", "some", "most", "all" oder  "char" enthalten, oder "-", um den Standardwert zu erzwingen. 
"char" bedeutet, dass das Symbol nur bei der zeichenweisen Navigation verarbeitet wird. 
Standardmäßig wird hier der vom Englischen geerbte Wert verwendet oder "all", falls es nichts zu erben geben sollte:-).
- beibehalten: Dieses Feld muss immer dann belegt sein, wenn ein bestimmtes Symbol unverarbeitet an den Synthesizer weitergegeben werden soll, um eine korrekte Aussprache zu ermöglichen. 
Beispiele hierfür sind Sonderzeichen, die Sprachpausen verursachen, wie z.B. der Punkt, das Komma etc.
Dieses Feld kann die folgenden Werte enthalten:
- never: Das Symbol wird nie beibehalten.
- always: das Symbol wird immer beibehalten.
- norep: Das Symbol wird nur dann beibehalten, wenn es nicht ersetzt wird (z.B. wenn der Anwender die Satzzeichen- und Symbolebene niedriger eingestellt hat, als für das betreffende Symbol.
- -: verwendet den Standardwert.
Standardmäßig wird der Wert vom englischen Sprachraum vererbt oder "never" verwendet, falls es nichts zu erben geben sollte.
-
Am ende der Zeile kann schließlich noch ein Anzeigename für ein Symbol vergeben werden.
Dieser Name wird Anwendern angezeigt, wenn sie die komplexen Symbole bearbeiten wollen. Er kann auch von übersetzern verwendet werden, um übersetzte Namen für die englischen komplexen Symbole bereitzustellen.

Hierzu einige Beispiele:
```
(	runde Klammer auf	most
```
Dies bedeutet, dass das Zeichen "(" als "Runde Klammer auf" gesprochen werden soll, wenn der Anwender die Satzzeichen- und Symbolebene auf "meiste" oder "alle" eingestellt hat.
```
,	Komma	all	always
```
Dies bedeutet, dass das Zeichen "," als "Komma" gesprochen werden soll, wenn als Satzzeichen- und Symbolebene "all" eingestellt ist. Außerdem wird das Zeichen immer unverändert an den Synthesizer übergeben, um Sprechpausen korrekt zu setzen.
```
. sentence ending	point	# . fin de phrase
```
Diese Zeile stammt aus der französischen Datei symbols.dic.
Sie besagt, dass das komplexe Symbol ". sentence ending" als "point" gesprochen werden soll..
Ebene und Einstellung zum Beibehalten des Symbols sind hier nicht angegeben, werden also vom englischen Sprachraum geerbt.
Ein anzeigename wird ebenfalls angegeben, sodass französische nvda-Nutzer wissen, was dieses Symbol bedeutet.

Bitte sehen Sie sich die Datei locale\en\symbols.dic für die englischsprachigen Symboldefinitionen an. 

+ Plugins +

++ Übersicht ++
Mittels der Plugins erhalten Sie die Möglichkeit, das Verhalten global oder in bestimmten Anwendungen nach Ihren Wünschen anzupassen.
Das sind unter anderem:
- Auf bestimmte Ereignisse reagieren, wenn sich zum Beispiel der Fokus verschiebt oder wenn sich die Eigenschaften eines Objekts ändern.
- Befehle implementieren, die an bestimmte Tastendrücke oder andere Eingabemethoden gebunden werden können.
- Das Verhalten bestimmter Steuerelemente beeinflussen oder weitere Funktionen hinzufügen.
- Unterstützung für Textinhalte oder komplexe Dokumente anpassen oder hinzufügen.
-

Dieser Abschnitt enthält lediglich eine Einführung in die Entwicklung von Plug-ins. Schauen Sie sich die Code-Dokumentation für eine komplette Referenz an.

++ Typen der Plugins ++
Folgende zwei Typen der Plugins gibt es:
- Anwendungsmodule: Enthalten speziellen Code für eine bestimmte Anwendung.
Ein Anwendungsmodul nimmt Ereignisse für eine bestimmte Anwendung entgegen, auch wenn die Anwendung momentan nicht fokussiert ist.
Wenn eine Anwendung fokussiert ist, kann der Nutzer sämtliche Befehle ausführen, die im Anwendungsmodul definiert und an Eingabemethoden zugewiesen wurden.
- Allgemeine Plugins: Diese enthalten Code, die überall, auch in allen Anwendungen funktionieren. 
Dabei nehmen Sie alle Ereignisse von allen Elementen im Betriebssystem entgegen.
Befehle, die in allgemeinen Plugins an Eingabemethoden zugewiesen wurden, können unabhängig davon ausgeführt werden, welche Anwendung grade aktiv ist.
-

Wenn Sie vorhaben die Zugänglichkeit von NVDA für bestimmte Anwendungen zu verbessern, sind die Anwendungsmodule empfehlelnswert.
Im Gegensatz, wenn Sie vorhaben globalen Code für NVDA zu entwickeln, der systemweit zugänglich sein soll, zum Beispiel um sich die Signalstärke von Funknetzwerken anzeigen zu lassen, ist ein allgemeines Plugin empfehlenswert.

Anwendungsmodule und die allgemeinen Plugins sind sehr ähnlich.
Dies sind beides Python-Quelldateien (mit der Erweiterung .py), die dabei eine spezielle Klasse definieren, die sämtliche Ereignisse, Skripte und Komponenten beinhalten und die Zugriffssteuerung der eigenen Klassen, Textpassagen und komplexen Dokumenten definieren.
Dabei unterscheiden sie sich jedoch in einigen Punkten.

Die folgenden Abschnitte beschreiben separat die Anwendungsmodule und die allgemeinen Plugins Anschließend werden wieder allgemeinere Punkte erläutert.

++ Grundlagen eines Anwendungsmoduls ++
Anwendungsmodule besitzen die Erweiterung .py und haben den gleichen Namen wie die Anwendungen, für die sie verwendet werden sollen. 
Ein Anwendungsmodul für den Editor müsste zum Beispiel notepad.py heißen, weil die ausführbare Datei des Editors notepad.exe heißt.

Anwendungsmodule müssen im Unterordner "appModules" der Benutzerkonfiguration von nvda liegen. 
Weitere Informationen über den Standort Ihres benutzerspezifischen Konfigurationsverzeichnisses finden Sie im Benutzerhandbuch von NVDA.

Anwendungsmodule müssen eine Klasse "appModule" definieren, die alle Eigenschaften und Methoden von appModuleHandler.AppModule erbt.
Diese Klasse kann dann Ereignisse, Scripte, Eingabemethodenzuweisungen und anderen Code enthalten.
Details hierzu lesen Sie weiter unten.

Sobald NVDA erkennt, dass eine bestimmte Anwendung gestartet wird, wird dessen Anwendungsmodul geladen.
Wenn die betreffende Anwendung oder NVDA beendet wird, wird auch das Anwendungsmodul wieder entladen.

++ Beispiel 1: Ein Anwendungsmodul erzeugt Signaltöne bei Ereignissen, wenn sich der Fokus verändert ++[Example1]
Das folgende anwendungsmodul gibt jedes mal einen Signalton wieder, wenn sich innerhalb des Editors der Fokus ändert.
Dieses Beispiel veranschaulicht den grundsätzlichen Aufbau eines Anwendungsmoduls.

Fügen sie den Folgenden code zwischen den Start- und Endmarken (jedoch nicht die Marken selbst) in eine Datei mit dem Namen notepad.py und speichern Sie diese im Unterverzeichnis appmodules in ihrer benutzerspezifischen nvda-Konfiguration.
Übernehmen Sie hierbei auch alle Tab- und Leerzeichen.

Starten Sie anschließend nvda neu oder wählen Sie Plugins neu laden" aus dem Menü Extras, damit die Änderungen wirksam werden.

Öffnen Sie zu guter Letzt den Editor und bewegen Sie den Fokus innerhalb der Anwendung (z.B. innerhalb des Menüs, innerhalb von Dialogfeldern etc).
Sie sollten jedes mal einen Signalton hören, wenn sich der Fokus ändert.
Wenn sie sich jedoch außerhalb des Editors (z.B. im Explorer) befinden, sollten Sie keine Signaltöne hören.
 
```
--- Beginn ---
# nvda-Anwendungsmodul für den Editor
# Beispiel 1 aus dem Entwicklerhandbuch

import appModuleHandler

class AppModule(appModuleHandler.AppModule):

	def event_gainFocus(self, obj, nextHandler):
		import tones
		tones.beep(550, 50)
		nextHandler()

--- Ende ---
```

Dieses anwendungsmodul beginnt mit zwei Kommentarzeilen, die den Zweck des Anwendungsmoduls beschreiben.

Anschließend wird das Modul "appmodule" importiert, das die Basisklasse für Anwendungsmodule zur Verfügung stellt.

Als nächstes wird eine Klasse namens AppModule definiert, die von appModuleHandler.AppModule abgeleitet ist.

Innerhalb der Klasse werden ein oder mehr Ereignisse, scripte oder Eingabemethodenzuweisungen definiert.
Dieses Beispiel definiert ein Ereignis namens gainfocus (event_gainFocus), das bei jeder Ausführung einen kurzen Signalton abspielt.
Die Implementierung des Ereignisses ist für dieses Beispiel noch nicht wichtig, wichtig ist lediglich die Definition der Klasse.

Ereignisse werden weiter unten in diesem Handbuch näher erläutert.

Denken Sie - wie bei anderen Beispielen in diesem handbuch - daran, das erstellte anwendungsmodul zu löschen und nvda neu zu starten bzw. die Plugins neuzuladen, wenn sie ihre Tests abgeschlossen haben, um das ursprüngliche Verhalten von nvda wiederherzustellen.

++ Grundlagen der Allgemeinen Plugins ++
Globale Plug-ins sollten die Erweiterung .py besitzen und einen kurzen Namen haben, der ihren Zweck beschreibt.

Globale Plugins müssen im unterordner "globalplugins" des benutzerspezifischen Konfigurationsverzeichnisses liegen. 
Weitere Informationen darüber, wo sie das benutzerspezifische Konfigurationsverzeichnis finden, finden Sie im nvda-Benutzerhandbuch.

Globale Plugins müssen eine Klasse namens GlobalPlugin, definieren, die ein direkter Nachkomme von globalPluginHandler.GlobalPlugin ist.
Diese klasse kann anschließend Ereignisse, Script-Methoden, Eingabemethoden-zuweisungen und anderen Code enthalten.
All dies wird im Folgenden behandelt.

NVDA lädt alle globalen Plug-ins, sobald er gestartet wird und endlädt sie beim Beenden.

++ Beispiel 2: Eine Standarderweiterung - Ein Skript zur Ansage der NVDA-Version ++
Das folgende Beispiel erlaubt Ihnen, sich von überall im System aus mit der Tastenkombination nvda+Umschalt+v die NVDA-Version anzeigen zu lassen.
Das Beispiel dient lediglich dazu, den grundlegenden Aufbau globaler Plugins zu veranschaulichen.

Kopieren sie den folgenden Text zwischen den Anfangs- und Endmarkern (jedoch nicht die Marker selbst), in eine Datei namens beispiel2.py und speichern Sie diese im Unterofdner globalplugins ihres Nvda-Konfigurationsverzeichnisses.
Lassen sie dabei alle Tabs und Leerzeichen stehen.

Starten Sie nach dem Speichern entweder NVDA neu oder wählen aus dem menü Extras des nvda-Menüs den Befehl Plug-ins neu laden.

Von nun an können sie nvda+Umschalt+V drücken, um die nvda-version angesagt und in Braille angezeigt zu bekommen.

```
--- Beginn ---
# Plugin zur Ausgabe der Versionsinformationen in NVDA
# Beispiel 2 aus dem Entwicklerhaldbuch

import globalPluginHandler
import ui
import versionInfo

class GlobalPlugin(globalPluginHandler.GlobalPlugin):

	def script_announceNVDAVersion(self, gesture):
		ui.message(versionInfo.version)

	__gestures={
		"kb:NVDA+shift+v": "announceNVDAVersion",
	}

--- Ende ---
```

Dieses globale Plug-in beginnt mit zwei Kommentarzeilen, die den Zweck der Datei kurz beschreiben.

Anschließend wird das Modul globalPluginHandler importiert, sodass das Plug-in Zugriff auf die Basisklasse GlobalPlugin hat. 

Außerdem werden noch die Module UI und Versioninfo importiert, damit das Plugin die Versionsinformationen ausgeben kann. 

Als nächstes wird eine Klasse GlobalPlugin, definiert, die ein Nachkomme von globalPluginHandler.GlobalPlugin ist.

Innerhalb dieser Klasse werden ein oder mehrere Ereignisse, Scripte oder Eingabemethoden-Zuweisungen definiert.
In diesem Beispiel enthält die Klasse ein Script, das die Versionsinformationen ausgibt und eine eingabemethoden-Zuweisung, die dieses Script an nvda+Umschalt+V zuweist.
Die Details des Scripts und der Eingabemethodenzuweisung sind für dieses Beispiel jedoch nicht von Belang.
Das wichtigste ist die Klasse selbst.
 
Um das urspründliche Verhalten von NVDA wiederherzustellen, müssen Sie die globale Plugin-Datei löschen und nvda anschließend neu starten oder die Plugins neu laden.

++ NVDA-Objekte ++
NVDA stellt Steuerelemente und andere Bestandteile von Benutzeroberflächen in Form von nvda-Objekten dar.
Diese Objekte enthalten standardisierte Eigenschaften wie name, Typ, Wert, Status und Beschreibung. Dies erlaubt anderen Teilen von NVDA, diese Informationen über ein Objekt in verallgemeinerter Form abzufragen oder darzustellen.
Die Schaltfläche "ok" in einem Dialogfeld wird beispielsweise den Namen "ok" und den Steuerelementtyp "Schaltfläche" besitzen.
So ähnlich würde beispielsweise ein Kontrollkästchen mit der Beschriftung "ich stimme zu" den Namen "ich stimme zu", den Typ Kontrollkästchen und - falls aktiviert - den Status aktiviert besitzen.

Auch wenn es unterschiedliche Komponentenbausätze für Benutzeroberflächen und Zugänglichkeitsschnittstellen gibt,  abstrahieren nvda-Objekte diese unterschiede zu einer einheitlichen Form, gleichgültig, mit welchem Komponentenbausatz ein Steuerelement erzeugt wurde oder über welche ugänglichkeitsschnittstelle darauf zugegriffen wird. 
der oben angesprochene Schalter "ok" könnte also beispielsweise ein Java-Objekt sein. Genauso gut könnte er aber auch ein msaa-Objekt, ein iaccessible2-Objekt oder ein ui-automation-Element sein.

NVDA-Objekte haben viele Eigenschaften.
einige der nützlichsten sind:
- name: die Beschriftung des Steuerelements
- role: der Typ des Steuerelements, repräsentiert durch eine der ROLE_*-Konstanten aus dem Anwendungsmodul controltypes
Schaltfläche, Dialogfeld, Eingabefeld, Fenster und Kontrollkästchen sind nur einige Beispiele für Steuerelementtypen.
- states: Status des Steuerelements, repräsentiert durch einen Satz von 0 oder mehr STATE_*-Konstanten as dem Modul controltypes.
hervorhebbar, hervorgehoben, ausgewählt, auswählbar, erweitert, reduziert und aktiviert sind nur einige Beispiele für den Status.
- value: der Wert des Steuerelements z.B. der aktuelle Stand einer Fortschrittsanzeige oder der aktuelle gewählte Eintrag in einem Kombinationsfeld.
- description: eine kurze Beschreibung, die den Zweck des Steuerelements erläutert (üblicherweise identisch mit der Minihilfe).
- location: der Abstand eines Objektes von der oberen linken Ecke des Bildschirms sowie dessen Breite und Höhe in Form von Bildschirmkoordinaten.
- parent: das übergeordnete Objekt
das Übergeordnete Objekt eines Listeneintrags ist beispielsweise die Liste, die ihn enthält.
- next: das nächste Objekt in der logischen Reihenfolge
- previous: das vorige Objekt in der logischen Reihenfolge
- firstChild: der erste direkte Nachkomme eines Objekts.
der erste Nachkomme einer Liste ist beispielsweise deren erster Eintrag.
- lastChild: der letzte Nachkomme eines Objekts.
  - children: eine Liste aller Nachkommen eines Objekts (beispielsweise alle Einträge eines Menüs).
-

Es gibt auch noch Eigenschaften, die sich auf die vereinfachte Navigation beziehen wie  simpleParent, simpleNext, simpleFirstChild and simpleLastChild.
Diese entsprechen den oben beschriebenen Eigenschaften, NVDA filtert hier jedoch nutzlose Objekte aus.
Diese eigenschaften werden immer dann verwendet, wenn nvda's vereinfachter Darstellungsmodus aktiviert ist, wasder Normalfall ist.
Die vereinfachten Eigenschaften sind zwar leichter zu verwenden, die komplexeren Eigenschaften spiegeln jedoch diezugrundeliegende Objektstruktur des Betriebsystems wesentlich besser wieder.

Wenn Sie nvda-Plugins entwickeln, spielt es meistens keine Rolle, mit welchem Komponentenbausatz die Benutzeroberfläche erstellt wurde oder mit welcher Zugänglichkeitsschnittstelle sie darauf zugreifen müssen. Meistens können sie mit Standardeigenschaften auf die Objekte zugreifen wie z.B. dessen Namen, Wert oder Status.
Wenn Plug-ins komplexer werden, kann es jedoch erforderlich werden tiefer in die Objekte abzusteigen, um Komponentenbausatz- oder zugänglichkeitsschnittstellen-spezifische Informationen zu erhalten.

Es gibt drei Möglichkeiten, wie Plug-ins nvda-Objekte verwenden können:
- die meisten Ereignisse verarbeiten ein Argument, das dasjenige Objekt angibt, auf das sich das Ereignis bezieht.
Das Ereignis event_gainfocus übernimmt beispielsweise dasjenige Objekt als Parameter, das soeben den Fokus bekommen hat.
- Skripte und Ereignisse können Objekte verarbeiten Wie z.B. das aktuell hervorgehobene Objekt, das aktuelle navigatorobjekt oder den Desktop.
Anschließend könnte auf andere Objekte bezug genommen und Informationen von ihnen abgerufen werden.
- Das Plug-in könnte auch eine eigene nvda-Objektklasse definieren, um ein bestimmtes Steuerelement darin einzuschließen. Solche benutzerdefinierten nvda-Objekte können einem nvda-Objekt neue Fnktionalität geben, dessen Eigenschaften umwandeln etc.
-

Ebenso wie Anwendungsmodule oder globale Plug-ins können nvda-Objekte Scripte, Ereignisse und Eingabemethoden-zuweisungen enthalten.
 
++ Skripte und Tastenanbindung ++
Anwendungsmodule, globale Plug-ins und nvda-Objekte können Methoden enthalten, die an Ereignisse wie z.B. Tastendrücke zugewiesen werden können.
Auf solche Methoden greift nvda mit Hilfe von Skripten zu.

Ein Skript ist eine standard-Python-Instanzmethode, deren Name mit "Script_" beginnt, wie z.B. "script_sayDateTime".

Eine Script-Methode verarbeitet zwei Argumente:
- self: eine Referenz auf das Anwendungsmodul, globale Plug-in oder nvda-Objekt, von dem aus das Skript aufgerufen wird.
- gesture: ein Eingabemethoden-Objekt, das die Ausführung des Script verursacht hat.
-

Neben dem eigentlichen Skript muss noch ein eingabemethoden-Objekt definiert werden, damit nvda bekannt ist, durch welches Ereignis das Script aufgerufen werden soll.

Um eine Eingabemethode an ein Skript zuzuweisen,  kann ein spezielles Python-Wörterbuch namens "__gestures" als Klassenvariable definiert werden. Dies kann innerhalb eines anwendungsmoduls, eines globalen Plug-ins oder eines nvda-Objekts geschehen.
Diese Wörterbücher sollten Einträge mit den Eingabemethoden enthalten, die af die entsprechenden Scripts zeigen. Der name muss hierbei ohne das Präfix "Script_" angegeben werden.

Es gibt zwar noch kompliziertere und dynamischere Methoden, Eingabemethoden zuzuweisen, das Wörterbuch __gestures ist jedoch der einfachste Weg.
 
Der Bezeichner für eine Eingabemethode ist eine einfache Zeichenfolge, die die Eingabemethode repräsentiert.
Er enthält einen zweistelligen Code, der die Eingabequelle beschreibt, einen optionalen Gerätenamen in Klammern, einen Doppelpunkt und eine oder mehrere Tastenbezeichnungen, die durch ein Pluszeichen voneinander getrennt werden.

Einige Beispiele für eingabemethodenbezeichner sind:
- "kb:NVDA+shift+v"
- "br(freedomScientific):leftWizWheelUp"
- "kb(laptop):NVDA+t"
-

Aktuell werden folgende Eingabequellen unterstützt:
- kb: Tastatureingaben
- br: Tastendrücke und andere navigierende Eingaben an Braillezeilen
-

Wenn nvda eine Tastatureingabe registriert, sucht es in eine bestimmten Reihenfolge nach einr entsprechenden Eingabemethoden-Zuweisung.
Wurde eine Zuweisung gefunden, so wird das entsprechende Script asgeführt. Weder wird weiter nach Eingabemethoden-Zuweisungen gesucht, noch wird der Tastendruck ans Betriebssystem weitergereicht.

Folgende Reihenfolge wird bei der Suche nach Eingabemethodenzuweisungen verwendet:
- geladene globale Plug-ins
- Anwendungsmodul der aktiven Anwendung
- der Interceptor des nvda-Objekts, das den Fokus hat (wie beispielsweise ein virtueller Puffer).
- das nvda-Objekt, das den Fokus hat
- globale, eingebaute Befehle wie beispielsweise das Beenden von nvda, die Objektnavigation usw.
-

++ Beispiel 3: Ein globales Plugin zum Aufspüren von FensterKlassen und Steuerelementen ++
Das folgende globale Plug-in bewirkt, dass sie nvda-Pfeil_links drücken können, um die Fensterklasse des aktuellen Fensters zu erfahren. Ebenso können Sie nvda+Pfeil_rechts drücken, um die Steuerelement-id des aktuellen Objekts zu erfahren.
Das Beispiel veranschaulicht, wie sie ein Script und eine Eingabemethodenzuweisung in einem globalen Plug-in definieren.
 
Speichern Sie den Text innerhalb der Start- und Endmarken (jedoch nicht die Marken selbst) in einer Datei beispiel3.py im Unterverzeichnis globalplugins.
Achten Sie dabei darauf, alle Tabs und Leerzeichen exakt zu übernehmen.

Starten Sie nach dem speichern entweder nvda neu oder wählen Sie im nvda-Menü den Befehl Plug-ins neu laden aus dem Menü Extras.

```
--- Beginn ---
# Hilfs-Skript für nvda
# Beispiel 3 aus dem Entwicklerhandbuch

import globalPluginHandler
import ui
import api

class GlobalPlugin(globalPluginHandler.GlobalPlugin):

	def script_announceWindowClassName(self, gesture):
		focusObj = api.getFocusObject()
		name = focusObj.name
		windowClassName = focusObj.windowClassName
		ui.message("Das Fenster %s besitzt die Fensterklasse %s" % (name, windowClassName))

	def script_announceWindowControlID(self, gesture):
		focusObj = api.getFocusObject()
		name = focusObj.name
		windowControlID = focusObj.windowControlID
		ui.message("Das Fenster %s hat die Steuerelement-nummer %d" % (name, windowControlID))

	__gestures = {
		"kb:NVDA+leftArrow": "announceWindowClassName",
		"kb:NVDA+rightArrow": "announceWindowControlID",
	}

--- Ende ---
```

++ Ereignisse ++
wenn NVDA ein Betriebssystemereignis erkennt, so wird dieses abstrahiert und ein eignes Ereignis bei nvda-Objekten ausgelöst.

Wenngleich di meisten Ereignisse zu bestimmten Nvda-Objekte gehören  (wie z.B. Umbenennungen, Fokuserhalt, Statusänderung, usw.), können sie auf unterschiedlichen Ebenen verarbeitet werden.
Wird ein Ereignis behandelt, so wird es nicht mehr weitergereicht.
Das Weiterreichen des Ereignsses kann jedoch durch Code innerhalb der Ereignisbehandlungsroutine erzwungen werden, falls nötig.

Ereignisse werden in folgender Reihenfolge abgearbeitet:
- durch geladene globale Plug-ins
- durch das Anwendungsmodul, das dem Objekt zugeordnet wurde, bei dem das Ereignis eintrat.
- durch den Interceptor (falls vorhanden) der dem Objekt zugeordnet wurde, bei dem das Ereignis eintrat
- durch das nvda-Objekt selbst.
-

Ereignisse sind Python-Instanzmethoden, deren namen mit event_ beginnen, gefolgt von dem Namen des eigentlichen Ereignisses   (wie z.B.  gainFocus).

Diese Ereignismethoden verarbeiten unterschiedliche Argumente, abhängig davon, af welcher Ebene sie aufgerufen werden.

Wenn ein Ereignis, das sich auf ein nvda-Objekt bezieht im nvda-Objekt selbst definiert wird, akzeptiert es ein Argument namens "self", das die Instanz des nvda-Objekts darstellt.
einige Ereignisse verarbeiten noch zusätzliche Argumente, dies ist allerdings ziemlich selten.

Wird ein Ereignis, das sich auf ein nvda-Objekt bezieht, in einem globalen Plug-in, in einem Anwendungsmodul oder in einem Interceptor definiert, verarbeitet es die folgenden Argumente:
- self: die Instanz des Anwendungsmoduls, des globalen Plug-ins oder des Interceptors
- obj: das nvda-Objekt, das das Ereignis ausgelöst hat
- nextHandler: eine Funktion, die bei ihrem Aufruf das Ereignis weiter durchreicht.
-

einige häufig verwendete nvda-Objektereignisse sind:
- foreground: Dieses Objekt wurde zum neuen Vordergrundfenster d.h. zur neuen aktiven Anwendung
- gainFocus: Das Objekt erhielt soeben den Fokus
- loseFocus: das Objekt hat den Fokus verloren
- nameChange: Das Objekt wurde umbenannt
- valueChange: In dem Objekt wurde der Wert geändert (z.B. wenn in einem Kombinationsfeld ein neuer Eintrag ausgewählt wurde)
- stateChange: Das Objekt änderte seinen status (aktivieren/deaktivieren von Kontrollfeldern etc).
- caret: wird ausgelöst, sobald sich deer Systemcursor innerhalb des Objektes bewegt
- locationChange: wird ausgelöst, sobald ein objekt physisch auf dem Bildschirm verschoben wird.
-

Es gibt zwar noch viel mehr Ereignisse, die oben afeführten sind jedoch die gebräuchlichsten.

ein Beispiel für eine Ereignisbehandlungsroutine finden Sie im Beispiel 1.

++ Die Schlafmodus-Variablen der Anwendungsmodule ++
Anwendngsmodule besitzen eine sehr nützliche Eigenschaft namens "aleepmode". Diese Eigenschaft deaktiviert, wenn sie auf true gesetzt wird, fast alle Funktionen von nvda.
Der Schlafmodus ist nützlich für anwendung, die eigene Bildschirmlese-Funktionen besitzen oder für Spiele, bei denen man volle Kontrolle über die Tastatur benötigt.

Obwohl der Anwender den Schlafmodus mit nvda+umschalt+s ein- und ausschalten kann, kann der Entwickler trotzdem die Standardeinstellung des Schlafmodus vorgeben.
Dies geschied einfach durch setzen der Eigenschaft sleepmode auf true in der Klasse des Anwendungsmoduls.

++ Beispiel 4: Ein Schlafmodus-Anwendungsmodul ++
Der folgende Cde kann kopiert und im Anwendungsmodul-Verzeichnis in einer Datei für eine Anwendung gespeichert werden, für die sie den Schlafmodus aktivieren möchten.
Die Datei muss, wie immer, die Endung .py erhalten.

```
--- Beginn ---
import appModuleHandler

class AppModule(appModuleHandler.AppModule):

	sleepMode = True

--- Ende ---
```
 
++ Eigene NVDA-Objektklassen angeben ++
Um die Zugänglichkeit von anwendungen mit nvda zu verbessern, ist das Definieren von eigenen nvda-Objektklassen der effektivste Weg.
Dies erlaubt ihnen, die gesamte für ein Steuerelement relevante Logik an einer einzigen Stelle zusammenzufassen, anstatt sie auf verschiedene Plugin-Ereignisse aufzuteilen.

die definition einer eigenen Objektklasse erfolgt in zwei Schritten:
- Definieren der NVDA-Objektklasse und deren Skripte, Ereignisse, Eigenschaften und Eingabemethoden-Zuweisungen
- nvda mitteilen, dass diese Klasse in bestimmten Situationen zu verwenden ist, indem sie  sie mit Hilfe der Methode chooseNVDAObjectOverlayClasses auf plug-in-Ebene einbinden.
-

Wenn sie eigene nvda-Objektklassen definieren, haben sie viele nvda-Objekt-basisklassen zur Auswahl.
Diese Basisklassen enthalten die grundlegene Unterstützung von Betriebssystem- oder Zugänglichkeitsschnittstellen wie win32, msaa oder Java Access Bridge.
Sie sollten in der benutzerdefinierten Objektklasse üblicherweise die höchste Basisklasse erben.
Wenn Sie beispielsweise eine benutzerdefinierte Fensterklasse bei einem Steerelement verwenden wollen, dessen Fensterklasse "edit" istund dessen Steuerelement-id 15 ist, werden Sie vermutlich von der Klasse nvdaobjects.window.window erben wollen, weil es sich bei dem besagten Objekt um ein Fenster handelt.
so ähnlich werden Sie ihr Objekt von der Klasse NVDAObjects.IAccessible.IAccessible ableiten, wenn Sie nach der Eigenschaft accrole suchen wollen.
Außerdem sollten Sie genau wissen, welche Eigenschaften Sie bei ihrer benutzerdefinierten Klase überschreiben wollen.
Wenn sie beispielsweise eine iaccessible-spezifische Eigenschaft wie shouldAllowIAccessibleFocusEvent überschreiben wollen, müssen Sie ihr objekt von  NVDAObjects.IAccessible.IAccessible ableiten.

Die Methode  chooseNVDAObjectOverlayClasses kann in Anwendungsmodulen oder globalen Plug-ins eingesetzt werden.
Sie verarbeitet 3 Argumente:
+ self: die Instanz des anwendungsmoduls oder des globalen Plugins
+ obj: das Objekt, für das eine neue Klase ausgewählt werden soll
+ clsList: eine Python-Liste mit Klassen, die für das Objekt benutzt werden sollen.
+

Innerhalb dieser Methode sollten Sie entscheiden, welche benutzerdefinierten Objektklasse(n) das objekt verwenden soll, indem Sie dessen Eigenschaften prüfen.
Wenn eine benutzerdefinierte Klasse verwendet werden soll, können Sie sie in die Klassenliste (üblicherweise vorn) einfügen. Sie können auch von nvda ausgewählte Klassen aus der Liste entfernen, dies ist jedoch selten erforderlich.

++ Beispiel 5: Das Eingabefeld im Editor beschriften, welches ein eigenes NVDA-Objekt verwendet ++
Dieses Anwendungsmodul bringt nvda dazu, das Haupt-eingabefeld des Editors mit "Inhalt" zu benennen.
Das bedeutet, dass nvda "Inhalt Eingabefeld" sagen wird, sobald das Editorfenster den Fokus erhält.

Der folgende Code kann kopiert und in eine Textdatei eingefügt werden, welche den Namen notepad.py tragen muss und im Ordner AppModules gespeichert wird.


```
--- Beginn ---
import appModuleHandler
from NVDAObjects.window import Window

class AppModule(appModuleHandler.AppModule):

	def chooseNVDAObjectOverlayClasses(self, obj, clsList):
		if isinstance(obj, Window) and obj.windowClassName == "Edit" and obj.windowControlID == 15:
			clsList.insert(0, LabelledEditField)

class LabelledEditField(Window):

	name="Inhalt"

--- Ende ---
```

+ die Python-Konsole von nvda +

	Die Python-Konsole emuliert innerhalb von nvda den interaktiven Python-Interpreter.
Sie ist zur Fehlerbehebung oder zum Erkunden von nvda's Interna oder zum Erkunden von Zugänglichkeitsschnittstellen nützlich.

++ Verwendung ++
Die Konsole kann auf zwei Arten aktiviert werden:
- durch Drücken von nvda+Strg+Z.
Wenn sie die Konsole auf diese Art aktivieren, werden Informationen über den Zustand von nvda in Variablen gespeichert, die über die Konsole verfügbar sind.
Lesen Sie den Abschnitt zu  [Schnappschuss-Variablen #PythonConsoleSnapshotVariables] für weitere Informationen.
- durch Aufrufen des Befehls extras --> Python-Konsole im nvda-Menü.
-

Die Konsole ähnelt dem Standard-Python-Interpreter.
Die Eingabe wird zeilenweise abgearbeitet.
Die aktuelle Zeile wird durch Drücken von Eingabe abgearbeitet.
Mit den Pfeiltasten können sie durch die Ausgaben von ausgeführten Befehlen navigieren.

Die ausgabe des Befehls wird beim Drücken von Eingabe vorgelesen.
Mit f6 können sie zwischen Ein- und Ausgabefenster wechseln.

durch Schließen des Fensters wird die Sitzung lediglich verborgen. Dies macht es möglich, zur Konsole zurückzukehren und alle bisherigen Eingaben und Variablen beizubehalten


++ namensraum ++[PythonConsoleNamespace]

+++ automatische Importe +++
der einfachheit halber werden die folgenden Module und Variablen automatisch importiert:
sys, os, wx, log (aus logHandler), api, queueHandler, speech, braille

+++ Schnappschuss-Variablen +++[PythonConsoleSnapshotVariables]
Wann immer nvda+strg+z gedrückt wird, werden einige Variablen gesetzt, die eine Momentaufnahme von nvda darstellen.
Diese Variablen sind:
- focus: das objekt, das momentan den Fokus hat
- focusAnc: dieVorfahren des aktuell fokussierten objekts
- fdl: Focus difference level; i.e. the level at which the ancestors for the current and previous focus differ
- fg: das aktuelle Vordergrundfenster
- nav: das aktuelle Navigatorobjekt
- mouse: das Objekt, auf dem sich der Mauszeiger befindet
- brlRegions: die Braille-Regionen des aktiven Braille-Puffers
-

+ die Remote-Python-Konsole +
für Situationen, in denen Fehler in nvda über ein Netzwerk hinweg aus der Ferne korrigiert werden müssen, ist eine Remote-Python-Konsole verfügbar. 
Diese funktioniert ähnlich wie die weiter oben beschriebene [lokale Python-Konsole #PythonConsole], der Zugriff erfolgt jedoch über TCP.

Bitte bedenken Sie, dass dies ein hohes Sicherheitsrisiko darstellt. 
Sie sollten die remote-Python-Konsole nur dann aktivieren, wenn sie mit vertrauenswürdigen Netzwerken wie etwa vpns verbunden sind.

++ Verwendung ++
um die remote-Python-Konsole zu aktivieren, verwenden sie die lokale Python-Konsole und importieren sie remotePythonConsole. Rufen Sie anschließend remotePythonConsole.initialize() auf.
Jetzt können Verbindungen über den typ-Port 6832 aufgebaut werden.
Die eingabeaufzeichnungsliste für zuvor eingegebene Befehle wird nicht unterstützt.
Der Namensbereich ist identisch mit dem  [Namensbereich der lokalen Python-Konsole #PythonConsoleNamespace].

Es gibt jedoch einige weitere spezielle Funktionen:
- snap(): erstellt einen Schnappschuss des aktuellen Zustandes vbon nvda und speichert diesen in den [Schnappschuss-Variablen #PythonConsoleSnapshotVariables].
- rmSnap(): entfernt alle Schnappschuss-Variablen.
-

Ende des Dokuments.
